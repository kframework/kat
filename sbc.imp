// IMP Language
// ============

// ### Configuration


module IMP
  imports MAP

  configuration <imp>
                  <k> $PGM:Stmt </k>
                  <mem> .Map </mem>
                </imp>

  syntax KResult ::= Int | Bool


// ### Expressions


  syntax AExp  ::= Int | Id
                 | AExp "/" AExp [left, strict]
                 > AExp "+" AExp [left, strict]
                 | "(" AExp ")"  [bracket]
//----------------------------------------
  rule I1 / I2 => I1 /Int I2  requires I2 =/=Int 0
  rule I1 + I2 => I1 +Int I2



  syntax BExp  ::= Bool
                 | AExp "<=" AExp [seqstrict, latex({#1}\leq{#2})]
                 | "!" BExp       [strict]
                 > BExp "&&" BExp [left, strict(1)]
                 | "(" BExp ")"   [bracket]
//-----------------------------------------
  rule I1 <= I2   => I1 <=Int I2
  rule ! T        => notBool T
  rule true  && B => B
  rule false && _ => false


// ### Statements


  syntax Block ::= "{" "}"
                 | "{" Stmt "}"

  syntax Ids ::= List{Id,","}

  syntax Stmt  ::= Block
                 | "int" Ids ";"
                 | Id "=" AExp ";"                      [strict(2)]
                 | "if" "(" BExp ")" Block "else" Block [strict(1)]
                 | "while" "(" BExp ")" Block
                 > Stmt Stmt                            [left]
//------------------------------------------------------------
  rule {}              => .        [structural]
  rule {S}             => S        [structural]

  rule int .Ids ;      => .        [structural]
  rule S1:Stmt S2:Stmt => S1 ~> S2 [structural]

  rule <k> int (X,Xs => Xs) ; ... </k> <mem> Rho:Map (.Map => X |-> ?V:Int) </mem>
    requires notBool (X in keys(Rho))


// ### Semantics


  rule <k> X:Id        => I ... </k> <mem> ... X |-> I        ... </mem> [tag(lookup)]
  rule <k> X = I:Int ; => . ... </k> <mem> ... X |-> (_ => I) ... </mem> [tag(assignment)]

  rule if (true)  B:Block else _ => B:Block [tag(if), transition]
  rule if (false) _ else B:Block => B:Block [tag(if), transition]

  rule while (B) STMT => if (B) {STMT while (B) STMT} else {} [tag(while)]
endmodule


// Strategy Language
// =================


requires "imp.k"

module STRATEGY-IMP
  imports IMP
  imports STRATEGY
  imports KCELLS

  configuration <strategy>
                  initSCell(Init)
                  <state> initImpCell(Init) </state>
                  <analysis> .Analysis </analysis>
                </strategy>

//  syntax Strategy ::= "strategy" ":" Strategy "=====" Stmt
  syntax State    ::= "#current" | Cell
  syntax Analysis ::= ".Analysis"

//  rule <s> strategy : S ===== PGM => S </s> <state> _ => <imp> <k> PGM </k> <mem> .Map </mem> </imp> </state>
endmodule


// Strategy Predicates
// -------------------


module STRATEGY-HARNESS
  imports STRATEGY-IMP

  syntax Pred ::= "#true" | "#false" | "#pred" | "(" Pred ")" [bracket]
                | "not" Pred | Pred "or" Pred | Pred "and" Pred
//-------------------------------------------------------------
  rule <s> (not P => P ; not #pred) ; _ </s>
  rule <s> (#false ; not #pred => #true)  ; _ </s>
  rule <s> (#true  ; not #pred => #false) ; _ </s>

  rule <s> (P or Q => P ; #pred or Q) ; _ </s>
  rule <s> (#true  ; #pred or _ => #true) ; _ </s>
  rule <s> (#false ; #pred or Q => Q)     ; _ </s>

  rule <s> (P and Q ; S => P ; #pred and Q) ; _ </s>
  rule <s> (#true  ; #pred and Q ; S => Q)      ; _ </s>
  rule <s> (#false ; #pred and _ ; S => #false) ; _ </s>



  syntax Pred ::= "bool?"


// Strategy Statements
// -------------------


  syntax Strategy ::= Pred
                    | "skip"
                    | "{" Strategy "}"          [bracket]
                    | "(" Strategy ")"          [bracket]
                    | "?" Strategy ":" Strategy
                    > Strategy "*"
                    > Strategy ";" Strategy     [right]
                    > Strategy "|" Strategy     [right]
//-----------------------------------------------------
  rule skip ; S => S [structural]

  rule <s> (#true  ; ? S : _ => S) ; _ </s>
  rule <s> (#false ; ? _ : S => S) ; _ </s>

  rule <s> (S*     => try S ; ? S* : skip) ; _ </s>
  rule <s> (S | S' => try S ; ? skip : S') ; _ </s>


// Strategy Primitives
// -------------------


  syntax priority try_ > _*
  syntax Strategy ::= "try" Strategy | "#try" State
//-------------------------------------------------
//  rule <s> (try S => S ; #try (state STATE)) ; _ </s> <state> STATE </state>
  rule <s> (#try STATE => #true)             ; _ </s>

  rule <s> #STUCK ~> SA:StrategyApply ; #try STATE ; S => load STATE ; #false ; S </s>
  rule <s> SA:StrategyApplied ~> S => S </s>



  syntax Strategy ::= "load" State
//--------------------------------
  rule <s> (load #current      => skip) ; _ </s>
//  rule <s> (load (state STATE) => skip) ; _ </s> <state> _ => STATE </state>

  syntax Strategy ::= "analysis" Analysis
//---------------------------------------
  rule <s> (analysis A => skip) ; _ </s> <analysis> _ => A </analysis>



  syntax Strategy ::= "step-with" Strategy
//----------------------------------------
  rule <s> (step-with S => (^ heat | ^ regular)* ; S ; (^ cool)*) ; _ </s>

  syntax Strategy ::= "step" | "#step"
//------------------------------------
  rule <s> (step => step-with #step) ; _ </s>


// Strategy Macros
// ---------------


  syntax Pred ::= "can?" Strategy
//-------------------------------
//  rule <s> (can? S => try S ; ? load (state STATE) ; #true : #false) ; _ </s> <state> STATE </state>

  syntax Pred ::= "stuck?"
//------------------------
  rule <s> (stuck? => not can? step) ; _ </s>



  syntax priority while__ while___ > _*
  syntax Strategy ::= "while" Pred Strategy | "while" Int Pred Strategy
//---------------------------------------------------------------------
  rule <s> (while P S => P ; (? S ; while P S : skip)) ; _ </s>

  rule <s> (while 0 P S => skip) ; _ </s>
  rule <s> (while N P S => P ; (? S ; while (N -Int 1) P S : skip)) ; _ </s> requires N >Int 0

  syntax priority step-until_ step-until__ > _*
  syntax Strategy ::= "step-until" Pred | "step-until" Int Pred
//-------------------------------------------------------------
  rule <s> (step-until   P => while   (not P) step) ; _ </s>
  rule <s> (step-until N P => while N (not P) step) ; _ </s> requires N >Int 0



  syntax priority exec_ exec__ > _*
  syntax Strategy ::= "exec" State | "exec" Int State
//---------------------------------------------------
  rule <s> (exec         STATE => load STATE ; step-until   stuck?) ; _ </s>
  rule <s> (exec (N:Int) STATE => load STATE ; step-until N stuck?) ; _ </s>

  syntax priority eval_ eval__ > _*
  syntax Strategy ::= "eval" State | "eval" Int State
//---------------------------------------------------
//  rule <s> (eval         STATE => exec   STATE ; bool? ; load (state STATE')) ; _ </s> <state> STATE' </state>
//  rule <s> (eval (N:Int) STATE => exec N STATE ; bool? ; load (state STATE')) ; _ </s> <state> STATE' </state>
endmodule


// K Analysis Tools (KAT)
// ======================


requires "imp.k"
requires "strategy.k"
requires "kat.k"

module IMP-KAT
  imports IMP-BIMC
  imports IMP-SBC



//  rule <s> (bool? => #true)  ; _ </s> <state> <k> true  </k> ... </state>
//  rule <s> (bool? => #false) ; _ </s> <state> <k> false </k> ... </state>
endmodule


// Bounded Invariant Model Checking
// --------------------------------


module STRATEGY-BIMC
  imports STRATEGY-HARNESS

  syntax State
  syntax Pred

  syntax Trace ::= ".Trace"
                 | Trace ";" State

  syntax Analysis ::= Trace



  syntax Strategy ::= "record"
//----------------------------
//  rule <s> (record => skip) ; _ </s> <analysis> T => T ; S </analysis>
//                                     <state> S </state>



  syntax Strategy ::= "assertion-failure" Pred | "assertion-success"



  syntax Strategy ::= "bimc" Int Pred
//-----------------------------------
  rule <s> ( bimc N P
           => { analysis .Trace
              ; record
              ; while N P
                  { step
                  ; record
                  }
              ; P ; ? assertion-success : assertion-failure P
              }
           )
           ; _
       </s>
endmodule


// ### Instantiating to IMP


module IMP-BIMC
  imports IMP
  imports STRATEGY-BIMC

  syntax Pred ::= "bexp?" BExp
//----------------------------
//  rule <s> (bexp? B => eval (state <imp> <k> B </k> <mem> MEM </mem> </imp>)) ; _ </s> <state> <mem> MEM </mem> ... </state>
endmodule


// ### BIMC Examples


strategy : { step
           ; bimc 5 (bexp? (x <= 7))
           }

=====

int x ;
x = 0 ;
x = x + 15 ;


// ### Future Work

// Semantics Based Compilation
// ---------------------------


module STRATEGY-SBC
  imports STRATEGY-HARNESS

  syntax State
  syntax Pred

  syntax Rule ::= "<" State ">"
                | "<" State "-->" State ">"

  syntax Rules ::= ".Rules"
                 | Rules "," Rule

  syntax Analysis ::= Rules



  syntax Pred ::= "cut-point?" | "abstract"



  syntax Pred ::= "subsumed?" | State "subsumes" State
//----------------------------------------------------
  rule <s> (subsumed? => #subsumed? RS) ; _ </s> <analysis> RS </analysis>

  syntax Pred ::= "#subsumed?" Rules
//----------------------------------
  rule <s> (#subsumed? .Rules => #false)                                                      ; _ </s>
//  rule <s> (#subsumed? (RS , < LHS --> _ >) => (LHS subsumes (state STATE)) or #subsumed? RS) ; _ </s> <state> STATE </state>



  syntax Strategy ::= "begin-rule"
//--------------------------------
//  rule <s> (begin-rule => skip) ; _ </s> <analysis> RS => RS , < state STATE > </analysis>
//                                         <state> STATE </state>

  syntax Strategy ::= "end-rule"
//------------------------------
//  rule <s> (end-rule => skip)   ; _ </s> <analysis> RS , (< LHS > => < LHS --> state STATE >) </analysis>
//                                         <state> STATE </state>



  syntax Strategy ::= "compile"
//-----------------------------
  rule <s> ( compile
          => { analysis .Rules
             ; abstract
             ; begin-rule
             ; while (not (stuck? or subsumed?))
                 { step-until (stuck? or cut-point?)
                 ; end-rule
                 ; abstract
                 ; begin-rule
                 }
             ; end-rule
             }
           )
           ; _
       </s>
       <analysis> _ => .Rules </analysis>
endmodule


// ### Instantiating to IMP {#instantiating-to-imp-1}


module IMP-SBC
  imports IMP
  imports STRATEGY-SBC

// Define `cut-point?`
//--------------------
  rule <s> (cut-point? => #true)  ; _ </s> <k> while _ _ ... </k>
  rule <s> (cut-point? => #false) ; _ </s> [owise]

// Define `abstract`
//------------------
  rule <s> (abstract => #abstract keys(MEM)) ; _ </s> <mem> MEM </mem>

  syntax Strategy ::= "#abstract" Set | "#abstractKey" Id
//-------------------------------------------------------
  rule <s> (#abstract .Set            => skip)                                          ; _ </s>
  rule <s> (#abstract (SetItem(X) XS) => { #abstractKey X ; #abstract XS }) ; _ </s>
  rule <s> (#abstractKey X => skip) ; _ </s> <mem> ... X |-> (_ => ?V:Int) ... </mem>

// Define `_subsumes_`
//--------------------
  rule <s> (state (<imp> <k> KCELL </k> _ </imp>) subsumes state (<imp> <k> KCELL  </k> _ </imp>) => #true)  ; _ </s>
  rule <s> (state (<imp> <k> KCELL </k> _ </imp>) subsumes state (<imp> <k> KCELL' </k> _ </imp>) => #false) ; _ </s> requires KCELL =/=K KCELL'
endmodule


// ### SBC Examples


strategy : compile

=====

int n s ;

while (0 <= n) {
  n = n - 1 ;
  s = s + n ;
}


// ### Future Work {#future-work-1}

// Corrective Model Checking
// -------------------------
