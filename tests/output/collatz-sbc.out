// Running KAT
// ===========

// We'll use a simple testing harness in `bash` which just checks the output of
// `krun --search` against a supplied file. Run this with `bash runtests.sh`.

// SBC
// ---

// Here, we compile each program into a simpler set of rules specific to that
// program. Compilation must be run with `--search` so that when the state of
// symbolic execution splits at branch points (eg. `if(_)_else_` in IMP) we collect
// rules for both branches.

// ### Collatz {#collatz-1}

// Finally, we pick a program that has a conditional inside the `while` loop.
// Indeed, we get a summary of the Collatz program with four rules:

// 1.  A rule that gets us to the beginning of the `while` loop (initialization).
// 2.  A rule that gets us past the `while` loop once we reach 1.
// 3.  A rule that has the effect of the `while` loop if the branch inside is false
//     (roughly, "if the number is not 1 and odd, multiply by 3 and add 1").
// 4.  A rule that has the effect of the `while` loop if the branch inside is true
//     (roughly, "if the number is not 1 and even, divide it by 2").

// Rules 1 and 2 above will be generated in both solutions for `--search`, but
// rules 3 and 4 are each only generated in one of the solutions. Note that we
// effectively get a "summary" of the Collatz algorithm which is independent of how
// it's written down in IMP.


Solution 1
<kat>
 <s> #STUCK ~> #compile-result ( ( ( .Rules

                                     // RULE 1
                                   , < { int n , ( x , .Ids ) ; n = 782 ; x = 0 ; while ( 2 <= n ) { if ( n <= ( ( n / 2 ) * 2 ) ) { n = n / 2 ; } else { n = 3 * n + 1 ; } x = x + 1 ; } | .Map } --> { while ( 2 <= n ) { if ( n <= ( ( n / 2 ) * 2 ) ) { n = n / 2 ; } else { n = 3 * n + 1 ; } x = x + 1 ; } | x |-> 0 n |-> 782 } > )

                                     // RULE 2
                                   , < { while ( 2 <= n ) { if ( n <= ( ( n / 2 ) * 2 ) ) { n = n / 2 ; } else { n = 3 * n + 1 ; } x = x + 1 ; } | x |-> V0 n |-> V1 | false }                     --> { . | x |-> V0 n |-> V1 } > )

                                     // RULE 3
                                   , < { while ( 2 <= n ) { if ( n <= ( ( n / 2 ) * 2 ) ) { n = n / 2 ; } else { n = 3 * n + 1 ; } x = x + 1 ; } | x |-> V0 n |-> V1 | true }                      --> { while ( true ) { if ( n <= ( ( n / 2 ) * 2 ) ) { n = n / 2 ; } else { n = 3 * n + 1 ; } x = x + 1 ; } | x |-> ( V0 +Int 1 ) n |-> ( 3 *Int V1 +Int 1 ) } >
                                   ) </s>
 <imp>
  <k> while ( true ) { if ( n <= ( ( n / 2 ) * 2 ) ) { n = n / 2 ; } else { n = 3 * n + 1 ; } x = x + 1 ; } </k>
  <mem> x |-> V2 n |-> V3 </mem>
 </imp>
 <analysis> .Analysis </analysis>
 <states> .States </states>
</kat>

Solution 2
<kat>
 <s> #STUCK ~> #compile-result ( ( ( .Rules

                                     // RULE 1
                                   , < { int n , ( x , .Ids ) ; n = 782 ; x = 0 ; while ( 2 <= n ) { if ( n <= ( ( n / 2 ) * 2 ) ) { n = n / 2 ; } else { n = 3 * n + 1 ; } x = x + 1 ; } | .Map } --> { while ( 2 <= n ) { if ( n <= ( ( n / 2 ) * 2 ) ) { n = n / 2 ; } else { n = 3 * n + 1 ; } x = x + 1 ; } | x |-> 0 n |-> 782 } > )

                                     // RULE 2
                                   , < { while ( 2 <= n ) { if ( n <= ( ( n / 2 ) * 2 ) ) { n = n / 2 ; } else { n = 3 * n + 1 ; } x = x + 1 ; } | x |-> V0 n |-> V1 | false }                     --> { . | x |-> V0 n |-> V1 } > )

                                     // RULE 4
                                   , < { while ( 2 <= n ) { if ( n <= ( ( n / 2 ) * 2 ) ) { n = n / 2 ; } else { n = 3 * n + 1 ; } x = x + 1 ; } | x |-> V0 n |-> V1 | true }                      --> { while ( true ) { if ( n <= ( ( n / 2 ) * 2 ) ) { n = n / 2 ; } else { n = 3 * n + 1 ; } x = x + 1 ; } | x |-> ( V0 +Int 1 ) n |-> ( V1 /Int 2 ) } >
                                   ) </s>
 <imp>
  <k> while ( true ) { if ( n <= ( ( n / 2 ) * 2 ) ) { n = n / 2 ; } else { n = 3 * n + 1 ; } x = x + 1 ; } </k>
  <mem> x |-> V2 n |-> V3 </mem>
 </imp>
 <analysis> .Analysis </analysis>
 <states> .States </states>
</kat>


// Here we'll check the runtime of BIMC for the Collatz program, then compare to
// the time of BIMC of the system generated by SBC.

// We'll find the highest number that is reached on Collatz of 782 by incrementally
// increasing the maximum bound we check for as an invariant. This is mostly for
// benchmarking purposes.

// The first number is the `bound` on how high we'll let Collatz go. The second
// number is the number of steps it took to get there. The third number is how long
// it took to run on my laptop on a Sunday.

// 1.  1000 at 20 steps in 18s
// 2.  1174 at 40 steps in 22s
// 3.  2644 at 60 steps in \#\#TIME\#\#
// 4.  3238 at 730 steps in \#\#TIME\#\#
// 5.  4858 at 750 steps in \#\#TIME\#\#
// 6.  7288 at 770 steps in \#\#TIME\#\#
// 7.  9232 at 870 steps in \#\#TIME\#\#
