// IMP-KAT Tests
// =============

// This is a simple testing harness driven by the `tangle` script. Call
// `./tangle test` in the root directory to run the test-set.

// SBC
// ---

// Here, we compile each program into a simpler set of rules specific to that
// program. Compilation must be run with `--search` so that when the state of
// symbolic execution splits at branch points (eg. `if(_)_else_` in IMP) we collect
// rules for both branches.

// ### Straight Line

// Straight line programs should yield one rule which summarizes the effect of the
// entire program on the IMP memory.

// `straight-line-1` just has the effect of setting `x` to 15, skipping all
// intermediate steps.


<kat-imp>
 <s> #STUCK ~> #compile-result ( .Rules
                               , < { int x , .Ids ; x = 0 ; x = x + 15 ; | .Map } --> { . | x |-> 15 } >
                               ) </s>
 <kat>
  <analysis> .Analysis </analysis>
  <states> .States </states>
 </kat>
 <imp>
  <k> . </k>
  <mem> x |-> V0 </mem>
 </imp>
</kat-imp>


// `straight-line-2` just has the effect of setting `x` to 5, skipping all
// intermediate steps. Note that before setting it to `5`, the original program
// sets it to 0 and then 15, but the generated program does not have these steps.
// Because we are using the operational semantics of the language directly, we get
// this dead-code elimination practically for free.
