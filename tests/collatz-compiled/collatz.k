// Running KAT
// ===========

// We'll use a simple testing harness in `bash` which just checks the output of
// `krun --search` against a supplied file. Run this with `bash runtests.sh`.

// SBC
// ---

// Here, we compile each program into a simpler set of rules specific to that
// program. Compilation must be run with `--search` so that when the state of
// symbolic execution splits at branch points (eg. `if(_)_else_` in IMP) we collect
// rules for both branches.

// ### Collatz {#collatz-1}

// Finally, we pick a program that has a conditional inside the `while` loop.
// Indeed, we get a summary of the Collatz program with four rules:

// 1.  A rule that gets us to the beginning of the `while` loop (initialization).
// 2.  A rule that gets us past the `while` loop once we reach 1.
// 3.  A rule that has the effect of the `while` loop if the branch inside is false
//     (roughly, "if the number is not 1 and odd, multiply by 3 and add 1").
// 4.  A rule that has the effect of the `while` loop if the branch inside is true
//     (roughly, "if the number is not 1 and even, divide it by 2").

// Rules 1 and 2 above will be generated in both solutions for `--search`, but
// rules 3 and 4 are each only generated in one of the solutions. Note that we
// effectively get a "summary" of the Collatz algorithm which is independent of how
// it's written down in IMP.

// This corresponds to the following K definition (which imports the `IMP-SYNTAX`
// to get the correct parser). I've also replaced the `k` cells with constants,
// which can be done automatically using hashing but here is done manually.

// -   `INIT` corresponds to the entire program:
//     `int n , ( x , .Ids ) ; n = 782 ; x = 0 ; while ( 2 <= n ) { if ( n <= ( ( n / 2 ) * 2 ) ) { n = n / 2 ; } else { n = 3 * n + 1 ; } x = x + 1 ; }`
// -   `LOOP` corresponds to just the loop:
//     `while ( 2 <= n ) { if ( n <= ( ( n / 2 ) * 2 ) ) { n = n / 2 ; } else { n = 3 * n + 1 ; } x = x + 1 ; }`
// -   `FINISH` corresponds to the final state: `.`


requires "imp-kat.k"

module COLLATZ-COMPILED
  imports IMP-ANALYSIS
  imports MAP

  syntax KItem ::= "INIT" | "LOOP" | "FINISHED"

  rule <imp> <k> INIT => LOOP      </k> <mem> .Map => x |-> 0 n |-> 782                             </mem> </imp>
  rule <imp> <k> LOOP => FINISHED  </k> <mem> x |-> V0 n |-> V1                                     </mem> </imp> requires notBool (2 <=Int n)
  rule <imp> <k> LOOP              </k> <mem> x |-> (V0 => V0 +Int 1) n |-> (V1 => V1 /Int 2)       </mem> </imp> requires (2 <=Int n) andBool (n <=Int ((n /Int 2) *Int 2))
  rule <imp> <k> LOOP              </k> <mem> x |-> (V0 => V0 +Int 1) n |-> (V1 => (3 * V1) +Int 1) </mem> </imp> requires (2 <=Int n) andBool notBool (n <=Int ((n /Int 2) *Int 2))
endmodule


// Here we'll check the runtime of BIMC for the Collatz program, then compare to
// the time of BIMC of the system generated by SBC.

// We'll find the highest number that is reached on Collatz of 782 by incrementally
// increasing the maximum bound we check for as an invariant. This is mostly for
// benchmarking purposes.

// The first number is the `bound` on how high we'll let Collatz go. The second
// number is the number of steps it took to get there. The third number is how long
// it took to run on my laptop on a Sunday.

// 1.  1000 at 20 steps in 19s
// 2.  1174 at 40 steps in 22s
// 3.  1762 at 60 steps in ??s
// 4.  2644 at 730 steps in 2m34s
// 5.  3238 at 750 steps in 3m07s
// 6.  4858 at 770 steps in 3m44s
// 7.  7288 at 870 steps in 9m01s
// 8.  9232 at ??? steps in ?m??s
