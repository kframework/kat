// IMP-KAT Tests
// =============

// We'll use a simple testing harness in `bash` which just checks the output of
// `krun --search` against a supplied file. Run this with `bash runtests.sh`.

// SBC Benchmarking
// ----------------

// The above `compile` result for Collatz corresponds to the following K
// definition. We've replaced the `k` cells with constants, which can be done
// automatically using hashing but here is done manually.

// -   `INIT` corresponds to the entire program:
//     `int n , ( x , .Ids ) ; n = 782 ; x = 0 ; while ( 2 <= n ) { if ( n <= ( ( n / 2 ) * 2 ) ) { n = n / 2 ; } else { n = 3 * n + 1 ; } x = x + 1 ; }`
// -   `LOOP` corresponds to just the loop:
//     `while ( 2 <= n ) { if ( n <= ( ( n / 2 ) * 2 ) ) { n = n / 2 ; } else { n = 3 * n + 1 ; } x = x + 1 ; }`
// -   `FINISH` corresponds to the final state: `.`


requires "../../imp-kat.k"

module COLLATZ-COMPILED
  imports IMP-ANALYSIS
  imports MAP

  syntax Stmt ::= "INIT" | "LOOP" | "FINISHED"

  rule <imp> <k> INIT => LOOP      </k> <mem> .Map => x |-> 0                 n |-> 782                        </mem> </imp>
  rule <imp> <k> LOOP => FINISHED  </k> <mem>         x |-> V0                n |-> V1                         </mem> </imp> requires notBool (2 <=Int V1)                                         [tag(while)]
  rule <imp> <k> LOOP              </k> <mem>         x |-> (V0 => V0 +Int 1) n |-> (V1 => V1 /Int 2)          </mem> </imp> requires (2 <=Int V1) andBool (V1 <=Int ((V1 /Int 2) *Int 2))         [tag(while)]
  rule <imp> <k> LOOP              </k> <mem>         x |-> (V0 => V0 +Int 1) n |-> (V1 => (3 *Int V1) +Int 1) </mem> </imp> requires (2 <=Int V1) andBool notBool (V1 <=Int ((V1 /Int 2) *Int 2)) [tag(while)]
endmodule


// ### Concrete Execution Time

// First we'll demonstrate that execution time decreases drastically by running
// `collatz.imp` with the original semantics, and running `INIT` with the new
// semantics. Note that in both cases this is not as fast as an actual compiled
// definition could be because we're still using the strategy harness to control
// execution (which introduces overhead).

// ### BIMC Execution Time

// In addition to concrete execution speedup, we get a speedup in the other
// analysis tools that can be run after SBC. Here we'll check the runtime of BIMC
// for the Collatz program, then compare to the time of BIMC of the system
// generated by SBC.

// To do this, we'll find the highest number that is reached on Collatz of 782 by
// incrementally increasing the maximum bound we check for as an invariant.

// The first number is the `bound` on how high we'll let Collatz go. The second
// number is the number of steps it took to get there. The third number is how long
// it took to run on my laptop on a Sunday.

// 1.  1000 at 20 steps in 19s
// 2.  1174 at 40 steps in 22s
// 3.  1762 at 60 steps in ??s
// 4.  2644 at 730 steps in 2m34s
// 5.  3238 at 750 steps in 3m07s
// 6.  4858 at 770 steps in 3m44s
// 7.  7288 at 870 steps in 9m01s
// 8.  9232 at ??? steps in ?m??s
