// IMP-KAT Tests
// =============

// We'll use a simple testing harness in `bash` which just checks the output of
// `krun --search` against a supplied file. Run this with `bash runtests.sh`.

// SBC Benchmarking
// ----------------

// The above `compile` result for Collatz corresponds to the following K
// definition. We've replaced the `k` cells with constants, which can be done
// automatically using hashing but here is done manually.

// -   `INIT` corresponds to the entire program:
//     `int n , ( x , .Ids ) ; n = 782 ; x = 0 ; while ( 2 <= n ) { if ( n <= ( ( n / 2 ) * 2 ) ) { n = n / 2 ; } else { n = 3 * n + 1 ; } x = x + 1 ; }`
// -   `LOOP` corresponds to just the loop:
//     `while ( 2 <= n ) { if ( n <= ( ( n / 2 ) * 2 ) ) { n = n / 2 ; } else { n = 3 * n + 1 ; } x = x + 1 ; }`
// -   `FINISH` corresponds to the final state: `.`

// Here is the compiled version of Collatz all, which checks every Collatz number
// up to 10.

// -   `INIT` corresponds to the entire program.
// -   `OUTER` corresponds to the program starting at the outer `while` loop.
// -   `INNER` corresponds to the program starting at the inner `while` loop.
// -   `FINISHED` corresponds to the completed program.


requires "../../imp-kat.k"

module KRAZY-LOOP-INCORRECT-COMPILED
  imports IMP-ANALYSIS
  imports MAP

  syntax Stmt ::= "INIT" | "OUTER" | "INNER" | "FINISH"
  syntax Id ::= "i" | "j" | "k" | "l" | "m" | "s"

  rule <imp> <k> INIT  => OUTER  </k> <mem> .Map => i |-> 11                j |-> 11                k |-> 0                                                     l |-> 0                                   m |-> 0                        s |-> 0                           </mem> </imp>
  rule <imp> <k> OUTER => FINISH </k> <mem>         i |-> V0                j |-> V1                k |-> V2                                                    l |-> V3                                  m |-> V4                       s |-> V5                          </mem> </imp> requires notBool (0 <=Int V0) [tag(while)]
  rule <imp> <k> OUTER => INNER  </k> <mem>         i |-> V0                j |-> (V1 => 11)        k |-> (V2 => 0)                                             l |-> V3                                  m |-> V4                       s |-> V5                          </mem> </imp> requires (0 <=Int V0) [tag(while)]
  rule <imp> <k> INNER => OUTER  </k> <mem>         i |-> (V0 => V0 -Int 1) j |-> V1                k |-> V2                                                    l |-> V3                                  m |-> V4                       s |-> (V5 +Int V0 *Int V2 /Int 3) </mem> </imp> requires notBool (0 <=Int V1) [tag(while)]
  rule <imp> <k> INNER           </k> <mem>         i |-> V0                j |-> (V1 => V1 -Int 1) k |-> (V2 => V2 +Int V1 /Int (5 *Int V0 +Int 1))            l |-> (V3 => 3 *Int V1 -Int (V1 +Int V0)) m |-> (V4 => 5 *Int V0 +Int 1) s |-> V5                          </mem> </imp> requires (0 <=Int V1) andBool notBool (V0 <=Int (V0 /Int 2) *Int 2) [tag(while)]
  rule <imp> <k> INNER           </k> <mem>         i |-> V0                j |-> (V1 => V1 -Int 1) k |-> (V2 => V2 +Int (3 *Int V1 -Int (V1 +Int V0)) /Int V0) l |-> (V3 => 3 *Int V1 -Int (V1 +Int V0)) m |-> (V4 => 5 *Int V0 +Int 1) s |-> V5                          </mem> </imp> requires (0 <=Int V1) andBool (V0 <=Int (V0 /Int 2) *Int 2) [tag(while)]
endmodule


// ### Concrete Execution Time

// First we'll demonstrate that execution time decreases drastically by running
// `collatz.imp` with the original semantics, and running `INIT` with the new
// semantics. Note that in both cases this is not as fast as an actual compiled
// definition could be because we're still using the strategy harness to control
// execution (which introduces overhead).

// And we also are timing the `collatz-all` program concretely:

//   program       concrete (ms)   compiled (ms)
//   ------------- --------------- ---------------
//   collatz       31952           2782
//   collatz-all                   
// 

// ### BIMC Execution Time

// In addition to concrete execution speedup, we get a speedup in the other
// analysis tools that can be run after SBC. Here we'll check the runtime of BIMC
// for the Collatz program, then compare to the time of BIMC of the system
// generated by SBC.

// To do this, we'll find the highest number that is reached on Collatz of 782 by
// incrementally increasing the maximum bound we check for as an invariant.

// The first number is the `bound` on how high we'll let Collatz go. The second
// number is the number of steps it took to get there. The third number is how long
// it took to run on my laptop on a Sunday.

//   bound   concrete (ms)   compiled (ms)   speedup
//   ------- --------------- --------------- ---------
//   1000    2154            596             3.61
//   1174    3378            818             4.13
//   1762    4497            966             4.66
//   2644    43825           4673            9.78
//   3238    45397           4521            10.04
//   4858    44939           4707            9.55
//   7288    53164           5209            10.21
//   9323    71187           6851            10.39
// 
