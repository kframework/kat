// IMP-KAT Tests
// =============

// We'll use a simple testing harness in `bash` which just checks the output of
// `krun --search` against a supplied file. Run this with `bash runtests.sh`.

// SBC Benchmarking
// ----------------

// The above `compile` result for Collatz corresponds to the following K
// definition. We've replaced the `k` cells with constants, which can be done
// automatically using hashing but here is done manually.

// -   `INIT` corresponds to the entire program:
//     `int n , ( x , .Ids ) ; n = 782 ; x = 0 ; while ( 2 <= n ) { if ( n <= ( ( n / 2 ) * 2 ) ) { n = n / 2 ; } else { n = 3 * n + 1 ; } x = x + 1 ; }`
// -   `LOOP` corresponds to just the loop:
//     `while ( 2 <= n ) { if ( n <= ( ( n / 2 ) * 2 ) ) { n = n / 2 ; } else { n = 3 * n + 1 ; } x = x + 1 ; }`
// -   `FINISH` corresponds to the final state: `.`

// Here is the compiled version of Collatz all, which checks every Collatz number
// up to 10.

// -   `INIT` corresponds to the entire program.
// -   `OUTER` corresponds to the program starting at the outer `while` loop.
// -   `INNER` corresponds to the program starting at the inner `while` loop.
// -   `FINISHED` corresponds to the completed program.


requires "../../imp-kat.k"

module COLLATZ-ALL-COMPILED
  imports IMP-ANALYSIS
  imports MAP

  syntax Stmt ::= "INIT" | "OUTER" | "INNER" | "FINISH"
  syntax Id ::= "x" | "b" | "n"

  rule <imp> <k> INIT  => OUTER  </k> <mem> .Map => x |-> 0                 b |-> 1                 n |-> 1                          </mem> </imp>
  rule <imp> <k> OUTER => FINISH </k> <mem>         x |-> V0                b |-> V1                n |-> V2                         </mem> </imp> requires notBool (V1 <=Int 10) [tag(while)]
  rule <imp> <k> OUTER => INNER  </k> <mem>         x |-> V0                b |-> V1                n |-> (V2 => V1)                 </mem> </imp> requires (V1 <=Int 10) [tag(while)]
  rule <imp> <k> INNER => OUTER  </k> <mem>         x |-> V0                b |-> (V1 => V1 +Int 1) n |-> V2                         </mem> </imp> requires notBool (2 <=Int V2) [tag(while)]
  rule <imp> <k> INNER           </k> <mem>         x |-> (V0 => V0 +Int 1) b |-> V1                n |-> (V2 => (3 *Int V2) +Int 1) </mem> </imp> requires (2 <=Int V2) andBool notBool (V2 <=Int ((V2 /Int 2) *Int 2)) [tag(while)]
  rule <imp> <k> INNER           </k> <mem>         x |-> (V0 => V0 +Int 1) b |-> V1                n |-> (V2 => V2 /Int 2)          </mem> </imp> requires (2 <=Int V2) andBool (V2 <=Int ((V2 /Int 2) *Int 2)) [tag(while)]
endmodule


// ### Concrete Execution Time

// First we'll demonstrate that execution time decreases drastically by running
// `collatz.imp` with the original semantics, and running `INIT` with the new
// semantics. Note that in both cases this is not as fast as an actual compiled
// definition could be because we're still using the strategy harness to control
// execution (which introduces overhead).

// And we also are timing the `collatz-all` program concretely:

//   program       concrete (ms)   compiled (ms)
//   ------------- --------------- ---------------
//   collatz       31952           2782
//   collatz-all                   
// 

// ### BIMC Execution Time

// In addition to concrete execution speedup, we get a speedup in the other
// analysis tools that can be run after SBC. Here we'll check the runtime of BIMC
// for the Collatz program, then compare to the time of BIMC of the system
// generated by SBC.

// To do this, we'll find the highest number that is reached on Collatz of 782 by
// incrementally increasing the maximum bound we check for as an invariant.

// The first number is the `bound` on how high we'll let Collatz go. The second
// number is the number of steps it took to get there. The third number is how long
// it took to run on my laptop on a Sunday.

//   bound   concrete (ms)   compiled (ms)   speedup
//   ------- --------------- --------------- ---------
//   1000    2154            596             3.61
//   1174    3378            818             4.13
//   1762    4497            966             4.66
//   2644    43825           4673            9.78
//   3238    45397           4521            10.04
//   4858    44939           4707            9.55
//   7288    53164           5209            10.21
//   9323    71187           6851            10.39
// 
