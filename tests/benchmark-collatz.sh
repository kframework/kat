# IMP-KAT Tests
# =============

# This is a simple testing harness driven by the `tangle` script. Call
# `./tangle test` in the root directory to run the test-set.

# SBC Benchmarking
# ----------------

# The above `compile` result for Collatz corresponds to the following K
# definition. We've replaced the `k` cells with constants, which can be done
# automatically using hashing but here is done manually.

# -   `INIT` corresponds to the entire program:
#     `int n , ( x , .Ids ) ; n = 782 ; x = 0 ; while ( 2 <= n ) { if ( n <= ( ( n / 2 ) * 2 ) ) { n = n / 2 ; } else { n = 3 * n + 1 ; } x = x + 1 ; }`
# -   `LOOP` corresponds to just the loop:
#     `while ( 2 <= n ) { if ( n <= ( ( n / 2 ) * 2 ) ) { n = n / 2 ; } else { n = 3 * n + 1 ; } x = x + 1 ; }`
# -   `FINISH` corresponds to the final state: `.`

# Here is the compiled version of Collatz all, which checks every Collatz number
# up to 10.

# -   `INIT` corresponds to the entire program.
# -   `OUTER` corresponds to the program starting at the outer `while` loop.
# -   `INNER` corresponds to the program starting at the inner `while` loop.
# -   `FINISHED` corresponds to the completed program.

# ### Concrete Execution Time

# First we'll demonstrate that execution time decreases drastically by running
# `collatz.imp` with the original semantics, and running `INIT` with the new
# semantics. Note that in both cases this is not as fast as an actual compiled
# definition could be because we're still using the strategy harness to control
# execution (which introduces overhead).


echo "Timing IMP Collatz concrete ..."
krun --directory '../' -cSTRATEGY='step until stuck?' collatz.imp
echo "Timing Compiled Collatz concrete ..."
krun --directory 'collatz-compiled/' -cSTRATEGY='step until stuck?' -cPGM='INIT'


# And we also are timing the `collatz-all` program concretely:

#   program       concrete (ms)   compiled (ms)
#   ------------- --------------- ---------------
#   collatz       31952           2782
#   collatz-all                   
# 

# ### BIMC Execution Time

# In addition to concrete execution speedup, we get a speedup in the other
# analysis tools that can be run after SBC. Here we'll check the runtime of BIMC
# for the Collatz program, then compare to the time of BIMC of the system
# generated by SBC.

# To do this, we'll find the highest number that is reached on Collatz of 782 by
# incrementally increasing the maximum bound we check for as an invariant.


for bound in 1000 1174 1762 2644 3238 4858 7288 9323; do
    echo
    echo "Timing Collatz bimc with bound '$bound' ..."
    echo "Using concrete execution ..."
    krun --directory '../' -cSTRATEGY='step-with skip ; bimc 5000 (bexp? n <= '"$bound"')' collatz.imp

    echo "Using compiled execution ..."
    krun --directory 'collatz-compiled/' -cSTRATEGY='step-with skip ; bimc 5000 (bexp? n <= '"$bound"')' -cPGM='INIT'
done


# The first number is the `bound` on how high we'll let Collatz go. The second
# number is the number of steps it took to get there. The third number is how long
# it took to run on my laptop on a Sunday.

#   bound   concrete (ms)   compiled (ms)   speedup
#   ------- --------------- --------------- ---------
#   1000    2154            596             3.61
#   1174    3378            818             4.13
#   1762    4497            966             4.66
#   2644    43825           4673            9.78
#   3238    45397           4521            10.04
#   4858    44939           4707            9.55
#   7288    53164           5209            10.21
#   9323    71187           6851            10.39
# 
