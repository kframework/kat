Program:  prelude.fun
Strategy: bounded-compile 1
================================================================================
<kat-FUN>
  <s>
    #STUCK ( )
  </s>
  <kat>
    <analysis>
      .Rules
    </analysis>
    <states>
      <FUN>
        <k>
          let ( id = fun ( x -> x ) | .Cases ) and fst = fun ( l -> fun ( r -> l ) | .Cases ) | .Cases and snd = fun ( l -> fun ( r -> r ) | .Cases ) | .Cases and cons = fun ( h -> fun ( t -> [ h : t ] ) | .Cases ) | .Cases and head = fun ( [ h : t ] -> h ) | .Cases and tail = fun ( [ h : t ] -> t ) | .Cases and apply = fun ( f -> fun ( d -> f d ) | .Cases ) | .Cases and .Bindings in apply id ( head ( tail [ 3 : 5 : 7 : 9 : .Vals ] ) )
        </k>
        <callStack>
          .
        </callStack>
        <env>
          .Map
        </env>
        <store>
          .Map
        </store>
        <nextLoc>
          0
        </nextLoc>
      </FUN> < ( ^ regular | ^ lookup | ^ assignment | ^ resetEnv | ^ switchFocus | ^ unwrapApplication ) * > : .States
    </states>
  </kat>
  <harness>
    <FUN>
      <k>
        bindTo ( id , fst , snd , cons , head , tail , apply , .Names , fun ( x -> x ) | .Cases : fun ( l -> fun ( r -> l ) | .Cases ) | .Cases : fun ( l -> fun ( r -> r ) | .Cases ) | .Cases : fun ( h -> fun ( t -> [ h : t ] ) | .Cases ) | .Cases : fun ( [ h : t ] -> h ) | .Cases : fun ( [ h : t ] -> t ) | .Cases : fun ( f -> fun ( d -> f d ) | .Cases ) | .Cases : .Vals ) ~> apply id ( head ( tail [ 3 : 5 : 7 : 9 : .Vals ] ) ) ~> setEnv ( .Map )
      </k>
      <callStack>
        .
      </callStack>
      <env>
        .Map
      </env>
      <store>
        .Map
      </store>
      <nextLoc>
        0
      </nextLoc>
    </FUN>
  </harness>
</kat-FUN>
