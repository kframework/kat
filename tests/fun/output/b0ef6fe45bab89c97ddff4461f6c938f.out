Program:  constructor-bst-sorting.fun
Strategy: exec
================================================================================
<kat-FUN>
  <s>
    #STUCK ( )
  </s>
  <kat>
    <analysis>
      .Analysis
    </analysis>
    <states>
      .States
    </states>
  </kat>
  <harness>
    <FUN>
      <k>
        [ .Names ]
      </k>
      <env>
        .Map
      </env>
      <store>
        1 |-> muclosure ( append |-> 3
        bst_sort |-> 1
        downto |-> 6
        flatten |-> 2
        insert |-> 5
        merge |-> 8
        mk_bst |-> 4
        shuffle |-> 9
        upto |-> 7 , l -> flatten ( mk_bst l ) | .Cases )
        2 |-> muclosure ( append |-> 3
        bst_sort |-> 1
        downto |-> 6
        flatten |-> 2
        insert |-> 5
        merge |-> 8
        mk_bst |-> 4
        shuffle |-> 9
        upto |-> 7 , Empty -> [ .Names ] | Node ( l , n , r , .Names ) -> append ( flatten l ) ( cons n ( flatten r ) ) | .Cases )
        3 |-> muclosure ( append |-> 3
        bst_sort |-> 1
        downto |-> 6
        flatten |-> 2
        insert |-> 5
        merge |-> 8
        mk_bst |-> 4
        shuffle |-> 9
        upto |-> 7 , [ .Names ] -> ( fun ( r -> r ) | .Cases ) | [ h , .Names | t ] -> ( fun ( r -> cons h ( append t r ) ) | .Cases ) | .Cases )
        4 |-> muclosure ( append |-> 3
        bst_sort |-> 1
        downto |-> 6
        flatten |-> 2
        insert |-> 5
        merge |-> 8
        mk_bst |-> 4
        shuffle |-> 9
        upto |-> 7 , [ .Names ] -> Empty | [ h , .Names | t ] -> insert ( mk_bst t ) h | .Cases )
        5 |-> muclosure ( append |-> 3
        bst_sort |-> 1
        downto |-> 6
        flatten |-> 2
        insert |-> 5
        merge |-> 8
        mk_bst |-> 4
        shuffle |-> 9
        upto |-> 7 , Empty -> ( fun ( n -> Node ( Empty , n , Empty , .Vals ) ) | .Cases ) | Node ( l , m , r , .Names ) -> ( fun ( n -> if n < m then Node ( insert l n , m , r , .Names ) else Node ( l , m , insert r n , .Names ) ) | .Cases ) | .Cases )
        6 |-> muclosure ( append |-> 3
        bst_sort |-> 1
        downto |-> 6
        flatten |-> 2
        insert |-> 5
        merge |-> 8
        mk_bst |-> 4
        shuffle |-> 9
        upto |-> 7 , 0 -> [ 0 , .Names ] | n -> cons n ( downto ( n - 1 ) ) | .Cases )
        7 |-> muclosure ( append |-> 3
        bst_sort |-> 1
        downto |-> 6
        flatten |-> 2
        insert |-> 5
        merge |-> 8
        mk_bst |-> 4
        shuffle |-> 9
        upto |-> 7 , 0 -> [ 0 , .Names ] | n -> append ( upto ( n - 1 ) ) [ n , .Names ] | .Cases )
        8 |-> muclosure ( append |-> 3
        bst_sort |-> 1
        downto |-> 6
        flatten |-> 2
        insert |-> 5
        merge |-> 8
        mk_bst |-> 4
        shuffle |-> 9
        upto |-> 7 , [ .Names ] -> ( fun ( [ .Names ] -> [ .Names ] ) | .Cases ) | [ h1 , .Names | t1 ] -> ( fun ( [ h2 , .Names | t2 ] -> cons h1 ( cons h2 ( merge t1 t2 ) ) ) | .Cases ) | .Cases )
        9 |-> muclosure ( append |-> 3
        bst_sort |-> 1
        downto |-> 6
        flatten |-> 2
        insert |-> 5
        merge |-> 8
        mk_bst |-> 4
        shuffle |-> 9
        upto |-> 7 , n -> merge ( downto n ) ( upto n ) | .Cases )
        10 |-> 10
        11 |-> 10
        12 |-> 9
        13 |-> 8
        14 |-> 7
        15 |-> 6
        16 |-> 5
        17 |-> 4
        18 |-> 3
        19 |-> 2
        20 |-> 1
        21 |-> 10
        22 |-> 9
        23 |-> 8
        24 |-> 7
        25 |-> 6
        26 |-> 5
        27 |-> 4
        28 |-> 3
        29 |-> 2
        30 |-> 1
        31 |-> [ 1 , .Names ]
        32 |-> [ 2 , .Names ]
        33 |-> [ 3 , .Names ]
        34 |-> [ 4 , .Vals ]
        35 |-> [ 5 , .Vals ]
        36 |-> [ 6 , .Names ]
        37 |-> [ 7 , .Names ]
        38 |-> [ 8 , .Vals ]
        39 |-> [ 9 , .Vals ]
        40 |-> [ 10 , .Vals ]
        41 |-> [ .Names ]
      </store>
    </FUN>
  </harness>
</kat-FUN>
