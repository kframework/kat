Program:  long-loop.fun
Strategy: exec-to-branch
================================================================================
<kat-FUN>
  <s>
    #STUCK ( ) ~> #which-can ^ caseFailure | ^ caseSuccess
  </s>
  <kat>
    <analysis>
      .Analysis
    </analysis>
    <states>
      .States
    </states>
  </kat>
  <harness>
    <FUN>
      <k>
        getMatching ( 0 , V0 ) ~> closure ( longLoop |-> 0 , 0 -> ( fun ( x -> fun ( y -> fun ( z -> 0 ) | .Cases ) | .Cases ) | .Cases ) | c -> ( fun ( x -> fun ( y -> fun ( z -> let ( y2 = y * x + ( 100 - z ) ) and .Bindings in let ( x2 = x + 1 ) and .Bindings in let ( z2 = z * z * x2 ) and .Bindings in let ( y3 = 30 + y2 ) and .Bindings in let ( z3 = 15 * y2 ) and .Bindings in let ( c2 = c - 1 ) and .Bindings in longLoop c2 x2 y3 z3 ) | .Cases ) | .Cases ) | .Cases ) | .Cases ) V0 ~> #arg ( 0 ) ~> #arg ( 0 ) ~> #arg ( 0 ) ~> setEnv ( .Map )
      </k>
      <extraComp>
        .
      </extraComp>
      <env>
        longLoop |-> 0
      </env>
      <store>
        0 |-> muclosure ( longLoop |-> 0 , 0 -> ( fun ( x -> fun ( y -> fun ( z -> 0 ) | .Cases ) | .Cases ) | .Cases ) | c -> ( fun ( x -> fun ( y -> fun ( z -> let ( y2 = y * x + ( 100 - z ) ) and .Bindings in let ( x2 = x + 1 ) and .Bindings in let ( z2 = z * z * x2 ) and .Bindings in let ( y3 = 30 + y2 ) and .Bindings in let ( z3 = 15 * y2 ) and .Bindings in let ( c2 = c - 1 ) and .Bindings in longLoop c2 x2 y3 z3 ) | .Cases ) | .Cases ) | .Cases ) | .Cases )
      </store>
      <nextLoc>
        1
      </nextLoc>
    </FUN>
  </harness>
</kat-FUN>
